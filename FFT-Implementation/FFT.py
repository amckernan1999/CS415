# -*- coding: utf-8 -*-
"""cs415project2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NIA8CkdcBt-7zyqzBTN4vsXaRu6XXIZz
"""

### CS415 Project 2 by Andrew McKernan & Kyler Schnaible

import math
import cmath
import random
import numpy as np
import scipy.signal as sc

def checkArrayLength(array):
  arrayLen = len(array)
  if math.log2(arrayLen).is_integer():          # if array length is a power of 2
    return array
  return checkArrayLength(np.append(array,0))   # if not a power of 2, check again with a 0 appended

def padArray(a,k):
  for i in range(k):
    a = np.append(a,0)
  return a

def clean(a):
  for i in range(len(a)):

    #rounds up
    if int(a[i] + 0.000001) != int(a[i]):
      a[i] = math.floor(a[i] + 0.000001)
    
    #rounds down
    elif int(a[i] - 0.000002) != int(a[i]) or a[i] < .000001:
      a[i] = math.ceil(a[i] - 0.000001)

    
    
  return a

aBig = [1.9999999, 49192.999999, .999999999, 0.999, 0, 0]
aLittle = [2.000000001, 19.9, 13.4, 0., .00000000000001]
aZero = [1,-2.99999999999999, 0.0000000001, -.00000000001]
aNeg = [-1.9999999, -1.0000001, 0, 0]

print(clean(aNeg))

def evenOddList(array):
  return array[0::2], array[1::2]

def FFT(a,w):
  # Input: An array a = (a0,a1,...,an−1), for n a power of 2
  # A primitive nth root of unity, ω(w)
  # Output: Mn(ω)a = FT of <a0,a1,...,a(n-1)> 
  if len(a) == 1: 
    return a

  aEven, aOdd = evenOddList(a)        # split the array into even and odd indexes


  v1 = FFT(aEven,pow(w,2))            # get Peven and evaluate at even powers of n. Peven = ( a[0] + a[2]x + a[4]x^2 + ... + a[n-2]x^(n-2)   ) 
  v2 = FFT(aOdd,pow(w,2))             # get X*Podd and evaluate at even powers of n. Podd = ( a[1] + a[3]x + a[5]x^2 + ... + s[n-1]x^((n/2)−1) )
  
  n = len(aEven)
  r = []
  
  wDepth = 1                          # wDepth stores which power we are at based on our loc in v
  for j in range(n):
    r.append(v1[j] + wDepth * v2[j])
    
    wDepth *= w
  
  wDepth = 1
  for j in range(n):
    r.append(v1[j] - wDepth * v2[j])
    wDepth *= w
  
  return r

def IFFT(a):
  n = len(a)
  w = complex(math.cos(2*math.pi/n), math.sin(2*math.pi/n))

  a = FFT(a,w)
  
  for j in range (n):
    a[j] /= n
  
  inverseA = []
  inverseA.append(a[0])

  for j in range(1,n):
    inverseA.append(a[n - j]) #appends values backwards
 
  return inverseA



def convolution (u,v):
  m = len(u)
  n = len(v)
  # find the smallest k such that 2k≥m+n−1.
  k = 1
  while 2**k < (m + n - 1):
    k +=1

  # add 2k−m zeros to u and 2k−n zeros to v so that they are both vectors of length 2**k
  u = padArray(u,2**k - m)
  v = padArray(v,2**k - n)

  w = complex(math.cos(2*math.pi/(2**k)), math.sin(2*math.pi/(2**k)))
  u1=FFT(u,w)
  v1=FFT(v,w)
 
  u3 = np.zeros(2**k, dtype=complex) # zero vector of length 2^k

  for j in range(len(u1)):
    u3[j] = u1[j] *  v1[j]
  
  u4 = IFFT(u3)



  return clean(u4)



def Poly(v):
  if len(v) == 1:
   
    return np.array([-v[0],1], dtype=complex)
  else:  
    v1,v2 = evenOddList(v)
    u1 = Poly(v1)
    u2 = Poly(v2)
    u = (convolution(u1, u2))
   
    # Trim so that u has no leading 0’s
    return u

def largestCoefficient(array):
  largest = 0
  for each in range(len(array)):
    if each > largest:
      largest = each
  return largest

def divide(A, B):
  # A is a vector of length n, and B is a vector of length m where m≤n
  # representing polynomials A(x) and B(x) where A(x) = B(x) * C(x)
  # Output is the vectorrepresentation of C(x) 
  

  A = checkArrayLength(A)
  B = checkArrayLength(B)

  
  if( len(A) > len(B)):
    B = padArray(B, len(A) - len(B))
  elif(len(A) < len(B)):
    A = padArray(A,len(B) - len(A))


  w = complex(math.cos(2*math.pi/len(A)), math.sin(2*math.pi/len(A))) 
  f1 = FFT(A,w)
  f2 = FFT(B,w)
                    
  f3 = np.zeros(len(f1), dtype=complex)        # Initialize a vector f3 of length t = |f1|.
 
  for j in range(len(f1)):
     
     if (f2[j] == 0):
       for k in range(len(f2)):
         B[k] += random.uniform(0, largestCoefficient(f2) * .0000001)
       return divide(A,B)           
     
     f3[j] = f1[j] /f2[j]
   
  
  f4=IFFT(f3)

  # Trim 0’s from f4 and output.
  return clean(f4)

"""User Interface"""

def problem1(file):
  # read file into variable
  v = file
  print(Poly(v))

def problem2(file1,file2):
  # read files into variables
  v1 = file1
  v2 =file2
  print(Poly(v))

option = input("Please input option 1-3: ")

while option != 3:
    if option == '1':
      file1 = input("Please input a file name: ")
      problem1(file1)
    elif option == '2':
      file1 = input("Please input the first file name: ")
      file2 = input("Please input the second file name: ")
      problem2(file1,file2)
    elif option == '3':
      break
    else:
      option = input("Please input a valid option 1-3: ")
    option = input("Please input option 1-3: ")

